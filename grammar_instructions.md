# XPath Syntax and Semantics Documentation

## Grammar

Any expression generated by the following context-free grammar is a valid XPath expression:

### Absolute Path (ap)
```
ap → doc(fileName)/rp | doc(fileName)//rp
```

### Relative Path (rp)
```
rp → tagName
   | *
   | .
   | ..
   | text()
   | @attName
   | (rp)
   | rp1/rp2
   | rp1//rp2
   | rp[f]
   | rp1,rp2
```

### Path Filter (f)
```
f → rp
   | rp1 = rp2
   | rp1 eq rp2
   | rp1 == rp2
   | rp1 is rp2
   | rp = StringConstant
   | (f)
   | f1 and f2
   | f1 or f2
   | not f
```

## Semantic Evaluation Functions

The semantics of XPath expressions are defined using three main functions:

- `[[ap]]A`: Returns the list of nodes reached by navigating from the root along absolute path ap
- `[[rp]]R(n)`: Returns the list of nodes reachable from element node n by navigating along relative path rp
- `[[f]]F(n)`: Returns true if and only if the filter f holds at node n

### Semantic Rules

1. Absolute Path Evaluation:
```
[[doc(fileName)/rp]]A = [[rp]]R(root(fileName))
[[doc(fileName)//rp]]A = [[.//rp]]R(root(fileName))
```

2. Relative Path Evaluation:
```
[[tagName]]R(n) = <c | c ← [[*]]R(n), tag(c) = tagName>
[[*]]R(n) = children(n)
[[.]]R(n) = <n>
[[..]]R(n) = parent(n)
[[text()]]R(n) = txt(n)
[[@attName]]R(n) = attrib(n, attName)
[[(rp)]]R(n) = [[rp]]R(n)
[[rp1/rp2]]R(n) = unique(<y | x ← [[rp1]]R(n), y ← [[rp2]]R(x)>)
[[rp1//rp2]]R(n) = unique([[rp1/rp2]]R(n), [[rp1/*//rp2]]R(n))
[[rp[f]]]R(n) = <x | x ← [[rp]]R(n), [[f]]F(x)>
[[rp1,rp2]]R(n) = [[rp1]]R(n),[[rp2]]R(n)
```

3. Filter Evaluation:
```
[[rp]]F(n) = [[rp]]R(n) ≠ <>
[[rp1 = rp2]]F(n) = [[rp1 eq rp2]]F(n) = ∃x ∈ [[rp1]]R(n) ∃y ∈ [[rp2]]R(n) x eq y
[[rp1 == rp2]]F(n) = [[rp1 is rp2]]F(n) = ∃x ∈ [[rp1]]R(n) ∃y ∈ [[rp2]]R(n) x is y
[[rp = StringConstant]]F(n) = ∃x ∈ [[rp]]R(n) x eq StringConstant
[[(f)]]F(n) = [[f]]F(n)
[[f1 and f2]]F(n) = [[f1]]F(n) ∧ [[f2]]F(n)
[[f1 or f2]]F(n) = [[f1]]F(n) ∨ [[f2]]F(n)
[[not f]]F(n) = ¬[[f]]F(n)
```

## List Operations

- List concatenation: `l1,l2` concatenates two lists
- `unique(l1)`: Removes duplicates from list by scanning from head to tail
- List comprehension: `<f(x) | x ← l1>` applies function f to each element x in list l1

### List Manipulation Examples:
```
<1,2,3>,<2,3,4> = <1,2,3,2,3,4>
unique(<1,2,3>,<2,3,4>) = <1,2,3,4>
```

## Equality Types

XPath distinguishes between two types of equality:

### Value-based Equality (eq or =)
Two XML nodes n and m are value-equal if and only if the trees rooted at them are isomorphic. This means:
- tag(n) = tag(m)
- text(n) = text(m)
- n has as many children as m
- For each k, the kth child of n and the kth child of m are value-equal

### Identity-based Equality (is or ==)
Two nodes are id-equal if and only if they are identical. A node n is only id-equal to itself, not to a copy of itself.

**Note**: Identity-based equality implies value-based equality, but not vice versa.

## Helper Functions

The following functions are used in XPath evaluation:

- `root(fn)`: Returns the root of the XML tree corresponding to document fn
- `children(n)`: Returns the list of children of element node n, ordered by document order
- `parent(n)`: Returns a singleton list containing the parent of element node n if it exists, empty list otherwise
- `tag(n)`: Returns the tag labeling element node n
- `txt(n)`: Returns the text node associated with element node n